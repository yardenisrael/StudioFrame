<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Enhanced SEO meta tags -->
  <title>Studio Frame - Free Online Animation Software | 2D Animation Tool | Pixel Art Animator | Best Animation Maker 2024</title>
  <meta name="description" content="Create professional 2D animations with Studio Frame - the best free online animation software. Perfect for pixel art, sprite animation, digital art, and frame-by-frame animation. Export to MP4, no download required. Features: onion skinning, layers, lasso tool, timeline editor. Start animating now!">
  <meta name="keywords" content="2D animation software, free animation tool, pixel art animator, sprite animation, frame by frame animation, online animation maker, digital art tool, animation software free, 2D animator, character animation, game animation, web animation, MP4 export, onion skinning, animation layers, timeline editor, lasso tool, drawing software, animation creator, professional animation tool, stop motion animation, flipbook animation, cartoon maker, animation studio, free animator, online animator, browser animation, HTML5 animation, canvas animation, vector animation, raster animation">
  <meta name="author" content="Studio Frame">
  <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
  <meta name="theme-color" content="#6366f1">
  <meta name="googlebot" content="index, follow">
  <meta name="bingbot" content="index, follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
  <meta name="format-detection" content="telephone=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://studioframe.live/">
  <meta property="og:title" content="Studio Frame - Best Free Online Animation Software 2024 | 2D Animation Tool">
  <meta property="og:description" content="Create stunning frame-by-frame animations directly in your browser. Free, powerful, and easy to use. Export as MP4 videos. No download required. Perfect for pixel art, sprite animation, and digital art.">
  <meta property="og:image" content="https://studioframe.live/favicon.png">
  <meta property="og:image:width" content="410">
  <meta property="og:image:height" content="410">
  <meta property="og:image:alt" content="Studio Frame Animation Tool Logo">
  <meta property="og:site_name" content="Studio Frame">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://studioframe.live/">
  <meta property="twitter:title" content="Studio Frame - Best Free Online Animation Software 2024 | 2D Animation Tool">
  <meta property="twitter:description" content="Create stunning frame-by-frame animations directly in your browser. Free, powerful, and easy to use. Export as MP4 videos. Perfect for pixel art, sprite animation, and digital art.">
  <meta property="twitter:image" content="https://studioframe.live/favicon.png">
  <meta property="twitter:image:alt" content="Studio Frame Animation Tool Logo">
  <meta property="twitter:creator" content="@FrameStudio">
  <meta property="twitter:site" content="@FrameStudio">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://studioframe.live/">
  
  <!-- Performance and SEO optimizations -->
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  
  <!-- Preload critical resources -->
  <link rel="preload" href="https://cdn.tailwindcss.com" as="style">
  <link rel="preload" href="./favicon.png" as="image">
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="./favicon.png?v=1">
  <link rel="shortcut icon" type="image/png" href="./favicon.png?v=1">
  <link rel="apple-touch-icon" href="./favicon.png?v=1">
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon.png?v=1">
  <link rel="icon" type="image/png" sizes="16x16" href="./favicon.png?v=1">
  <link rel="manifest" href="data:application/json,{&quot;name&quot;:&quot;Studio Frame&quot;,&quot;short_name&quot;:&quot;Studio Frame&quot;,&quot;description&quot;:&quot;Free online animation tool&quot;,&quot;start_url&quot;:&quot;/&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#0a0a0a&quot;,&quot;theme_color&quot;:&quot;#6366f1&quot;,&quot;icons&quot;:[{&quot;src&quot;:&quot;./favicon.png?v=1&quot;,&quot;sizes&quot;:&quot;410x410&quot;,&quot;type&quot;:&quot;image/png&quot;}]}">
  
  <!-- Schema.org structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Studio Frame - Free Online Animation Software",
    "alternateName": "Studio Frame Animation Tool",
    "description": "The best free online animation software for creating professional 2D animations, pixel art, sprite animations, and frame-by-frame animations. No download required. Export to MP4 videos with advanced features like onion skinning, multiple layers, and timeline editing.",
    "url": "https://studioframe.live/",
    "applicationCategory": "DesignApplication",
    "operatingSystem": "Any",
    "browserRequirements": "Requires JavaScript. Requires HTML5.",
    "softwareVersion": "1.0",
    "datePublished": "2024-01-01",
    "dateModified": "2024-12-19",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD",
      "availability": "https://schema.org/InStock"
    },
    "featureList": [
      "Frame-by-frame animation",
      "Multiple layer support",
      "Onion skinning",
      "Advanced drawing tools (brush, pencil, eraser, fill, lasso)",
      "Color palette with custom colors",
      "Animation preview with FPS control",
      "Export to MP4 video",
      "Undo/Redo functionality",
      "Keyboard shortcuts",
      "Mobile responsive design",
      "Desktop and phone viewport modes",
      "Layer management",
      "Frame duplication",
      "Zoom functionality",
      "Pixel art animation",
      "Sprite animation",
      "2D animation creation",
      "Digital art tools",
      "Timeline editor",
      "Professional animation features"
    ],
    "author": {
      "@type": "Organization",
      "name": "Studio Frame",
      "url": "https://studioframe.live/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Studio Frame",
      "url": "https://studioframe.live/"
    },
    "keywords": "2D animation software, free animation tool, pixel art animator, sprite animation, online animation maker, digital art tool, animation software free, 2D animator, character animation, game animation, web animation, MP4 export, onion skinning, animation layers, timeline editor, lasso tool, drawing software, animation creator, professional animation tool, stop motion animation, flipbook animation, cartoon maker, animation studio, free animator, online animator, browser animation, HTML5 animation, canvas animation, vector animation, raster animation",
    "inLanguage": "en-US",
    "isAccessibleForFree": true,
    "screenshot": "https://studioframe.live/favicon.png"
  }
  </script>
  
  <!-- Additional structured data for FAQ -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is Studio Frame?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Studio Frame is the best free online animation software for creating professional 2D animations, pixel art animations, and sprite animations. It offers advanced features like onion skinning, multiple layers, timeline editing, and MP4 export capabilities."
        }
      },
      {
        "@type": "Question",
        "name": "Is Studio Frame really free?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, Studio Frame is completely free to use with no hidden costs, watermarks, or limitations. You can create professional animations and export them as MP4 videos without any restrictions."
        }
      },
      {
        "@type": "Question",
        "name": "What types of animations can I create?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "You can create pixel art animations, sprite animations, 2D character animations, game animations, digital art animations, and frame-by-frame animations. Perfect for game developers, digital artists, and animation enthusiasts."
        }
      },
      {
        "@type": "Question",
        "name": "Do I need to download anything?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "No, Studio Frame is a web-based animation tool that works directly in your browser. No downloads or installations required. Just open the website and start creating animations."
        }
      },
      {
        "@type": "Question",
        "name": "Can I export my animations?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, you can export your animations as MP4 videos with customizable frame rates. The export feature supports high-quality video output without watermarks."
        }
      }
    ]
  }
  </script>
  
  <!-- Breadcrumb structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://studioframe.live/"
      },
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Animation Software",
        "item": "https://studioframe.live/#animation-software"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "name": "Free Online Animation Tool",
        "item": "https://studioframe.live/#free-animation-tool"
      }
    ]
  }
  </script>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Ensure FFmpeg is available globally
    window.FFmpeg = window.FFmpeg || FFmpeg;
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0a0a0a;
      color: #e5e5e5;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow-x: hidden;
    }




    /* Added mobile-responsive styles for collapsible sidebars */
    .sidebar-left, .sidebar-right {
      transition: transform 0.3s ease;
    }

    .menu-toggle {
      display: none;
      position: fixed;
      z-index: 1000;
      background: #1a1a1a;
      border: 2px solid #2a2a2a;
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .menu-toggle:hover {
      background: #252525;
      border-color: #6366f1;
    }

    .menu-toggle:active {
      transform: scale(0.95);
    }

    .menu-toggle-left {
      top: 70px;
      left: 10px;
    }

    .menu-toggle-right {
      top: 70px;
      right: 10px;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 998;
    }

    .overlay.active {
      display: block;
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .menu-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .sidebar-left {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        z-index: 999;
        transform: translateX(-100%);
        width: 280px;
        max-width: 85vw;
        overflow-y: auto;
        border-radius: 0;
      }

      .sidebar-left.open {
        transform: translateX(0);
      }

      .sidebar-right {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        z-index: 999;
        transform: translateX(100%);
        width: 280px;
        max-width: 85vw;
        overflow-y: auto;
        border-radius: 0;
      }

      .sidebar-right.open {
        transform: translateX(0);
      }

      /* Adjust viewport toggle for mobile */
      .viewport-toggle {
        position: relative;
        left: 0;
        transform: none;
        margin: 0 auto;
      }

      .viewport-btn {
        padding: 6px 12px;
        font-size: 12px;
      }

      /* Make canvas grid single column on mobile */
      .canvas-grid {
        grid-template-columns: 1fr !important;
      }

      /* Adjust top toolbar for mobile */
      .panel:first-child {
        flex-direction: column;
        gap: 12px;
        align-items: stretch;
      }

      .panel:first-child > div:first-child {
        justify-content: center;
      }

      .panel:first-child > div:last-child {
        justify-content: center;
      }
      
      /* Ensure phone dimension canvases fill height properly */
      .canvas-container {
        min-height: 400px;
      }
    }

    /* Improved border visibility with better box model */
    .canvas-container {
      position: relative;
      background: #1a1a1a;
      border: 6px solid #2a2a2a;
      border-radius: 12px;
      cursor: crosshair;
      transition: all 0.2s ease;
      aspect-ratio: var(--canvas-aspect-ratio, 1);
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      padding: 0;
      overflow: hidden;
      /* Ensure border is always visible */
      outline: 1px solid transparent;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    .canvas-container canvas {
      /* Make canvas fill container while maintaining aspect ratio */
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      /* Added transform origin for zoom functionality */
      transform-origin: center center;
      transition: transform 0.1s ease-out;
    }

    .canvas-container:hover {
      border-color: #3a3a3a;
    }

    .canvas-container.active {
      border-color: #6366f1;
      box-shadow: 0 0 0 1px #6366f1;
    }

    .tool-btn {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #a0a0a0;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-btn:hover {
      background: #252525;
      border-color: #3a3a3a;
      color: #e5e5e5;
    }

    .tool-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

    .slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: #2a2a2a;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #7c3aed;
      transform: scale(1.1);
    }

    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      border: none;
    }

    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 2px solid #2a2a2a;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .color-swatch:hover {
      border-color: #6366f1;
      transform: scale(1.05);
    }

    .frame-number {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: #a0a0a0;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      pointer-events: none;
      z-index: 10;
    }

    .onion-skin {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
    }

    input[type="color"] {
      width: 40px;
      height: 40px;
      border: 2px solid #2a2a2a;
      border-radius: 6px;
      background: #1a1a1a;
      cursor: pointer;
    }

    .panel {
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 16px;
    }

    .divider {
      width: 1px;
      height: 24px;
      background: #2a2a2a;
    }

    .kbd {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 11px;
      font-family: monospace;
      color: #a0a0a0;
    }

    .timeline-frame {
      width: 100%;
      height: 50px;
      border: 2px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      flex-shrink: 0;
      min-width: 50px;
    }

    .timeline-frame:hover {
      border-color: #3a3a3a;
    }

    .timeline-frame.active {
      border-color: #6366f1;
    }


    /* Timeline frame container for positioning ribs */
    .timeline-frame-container {
      position: relative;
      display: flex;
      align-items: center;
      min-width: 50px;
      width: 50px; /* Increased base width to accommodate duration text */
      transition: width 0.3s ease;
      flex-shrink: 0;
    }
    
    /* Ensure timeline frames maintain minimum width when extended */
    .timeline-frame-container[style*="width"] {
      min-width: 50px !important;
    }

    /* Enhanced Timeline Scroll Wheel - Modern App Design */
    #timeline-container {
      position: relative;
    }

    /* Add subtle glow effect to timeline container */
    #timeline-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(99, 102, 241, 0.1) 0%, 
        transparent 20%, 
        transparent 80%, 
        rgba(99, 102, 241, 0.1) 100%);
      pointer-events: none;
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #timeline-container:hover::before {
      opacity: 1;
    }


    /* Add scroll wheel momentum and inertia */
    .timeline-scroll {
      -webkit-overflow-scrolling: touch !important;
      scroll-behavior: smooth !important;
    }

    /* Draggable ribs on the sides of frames */
    .timeline-rib {
      position: absolute;
      width: 8px;
      height: 50px;
      background: #6366f1;
      cursor: ew-resize;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
      border-radius: 2px;
    }

    .timeline-rib-left {
      left: -4px;
    }

    .timeline-rib-right {
      right: -4px;
    }

    .timeline-frame-container:hover .timeline-rib {
      opacity: 0.7;
    }

    .timeline-rib:hover {
      opacity: 1 !important;
      background: #7c3aed;
    }

    .timeline-rib.dragging {
      opacity: 1 !important;
      background: #7c3aed;
      box-shadow: 0 0 8px rgba(124, 58, 237, 0.5);
    }

    /* Frame duration indicator */
    .frame-duration-indicator {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #a0a0a0;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      pointer-events: none;
      z-index: 5;
      white-space: nowrap;
    }

    /* Visual feedback during drag */
    .timeline-frame-container.dragging {
      position: relative;
    }

    .timeline-frame-container.dragging::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.1);
      border: 2px dashed #6366f1;
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
    }

    .status-bar {
      background: #0f0f0f;
      border-top: 1px solid #2a2a2a;
      padding: 8px 16px;
      font-size: 12px;
      color: #707070;
    }

    .layer-item {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    .layer-item:hover {
      background: #252525;
      border-color: #3a3a3a;
    }

    .layer-item.active {
      background: #2a2a3a;
      border-color: #6366f1;
    }

    .layer-visibility {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .layer-name {
      flex: 1;
      font-size: 12px;
    }

    .layer-delete {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .layer-item:hover .layer-delete {
      opacity: 1;
    }

    /* Improved grid layout for better responsiveness */
    .canvas-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      max-width: 1400px;
      margin: 0 auto;
      align-items: stretch;
    }

    @media (min-width: 768px) {
      .canvas-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (min-width: 1024px) {
      .canvas-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Added styles for viewport toggle button */
    .viewport-toggle {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 4px;
    }

    .viewport-btn {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #a0a0a0;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .viewport-btn:hover {
      background: #252525;
      border-color: #3a3a3a;
      color: #e5e5e5;
    }

    .viewport-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

  </style>
</head>
<body>

  <!-- Added hamburger menu toggles for mobile -->
  <button class="menu-toggle menu-toggle-left" onclick="toggleLeftSidebar()" aria-label="Toggle tools menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/>
      <circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/>
      <circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/>
      <circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/>
      <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>
    </svg>
  </button>

  <button class="menu-toggle menu-toggle-right" onclick="toggleRightSidebar()" aria-label="Toggle layers menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 2L2 7l10 5 10-5-10-5z"/>
      <path d="M2 17l10 5 10-5"/>
      <path d="M2 12l10 5 10-5"/>
    </svg>
  </button>

  <!-- Added overlay for mobile sidebar -->
  <div class="overlay" id="sidebar-overlay" onclick="closeSidebars()"></div>

  <div class="flex flex-col h-screen">
    <!-- Top Toolbar -->
    <div class="panel border-b border-[#2a2a2a] rounded-none flex items-center justify-between px-6 py-3 relative">
      <div class="flex items-center gap-4">
        <div class="flex items-center gap-3">
          <img src="favicon.png" alt="Studio Frame Logo" class="w-8 h-8 rounded-lg" style="width: 32px; height: 32px;">
          <h1 class="text-xl font-bold text-white">Studio Frame</h1>
        </div>
        <div class="divider"></div>
        <span class="text-sm text-gray-500">Free Online Animation Tool</span>
        <a href="features.html" class="ml-4 text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200">
          Features
        </a>
        <a href="tutorials.html" class="ml-4 text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200">
          Tutorials
        </a>
      </div>
      
      <div class="viewport-toggle">
        <button class="viewport-btn" id="desktop-btn" onclick="setViewport('desktop')">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          Desktop
        </button>
        <button class="viewport-btn active" id="phone-btn" onclick="setViewport('phone')">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="5" y="2" width="14" height="20" rx="2" ry="2"/>
            <line x1="12" y1="18" x2="12.01" y2="18"/>
          </svg>
          Phone
        </button>
      </div>
      
      <div class="flex items-center gap-2">
        <button class="bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold px-4 py-2 rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex items-center gap-2" onclick="exportAnimation()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
          </svg>
          Export MP4
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
      <!-- Added sidebar-left class for mobile responsiveness -->
      <!-- Left Sidebar - Tools -->
      <div class="w-64 panel border-r border-[#2a2a2a] rounded-none flex flex-col gap-6 overflow-y-auto sidebar-left" id="left-sidebar">
        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Drawing Tools</h3>
          <div class="flex flex-col gap-2">
            <button class="tool-btn active" id="brush-btn" onclick="setTool('brush')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/>
                <path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z"/>
              </svg>
              Brush <span class="kbd ml-auto">B</span>
            </button>
            <button class="tool-btn" id="pencil-btn" onclick="setTool('pencil')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
              </svg>
              Pencil <span class="kbd ml-auto">P</span>
            </button>
            <button class="tool-btn" id="eraser-btn" onclick="setTool('eraser')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/>
                <path d="M22 21H7"/>
                <path d="m5 11 9 9"/>
              </svg>
              Eraser <span class="kbd ml-auto">E</span>
            </button>
            <button class="tool-btn" id="fill-btn" onclick="setTool('fill')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m4 13 3.5-3.5a2.8 2.8 0 1 1 4 4L8 17"/>
                <path d="M13 8 7 2 2 7l6 6"/>
                <path d="m18 22 4-4-4-4-4 4z"/>
              </svg>
              Fill <span class="kbd ml-auto">F</span>
            </button>
            <button class="tool-btn" id="lasso-btn" onclick="setTool('lasso')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
              </svg>
              Lasso <span class="kbd ml-auto">L</span>
            </button>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Color</h3>
          <div class="flex items-center gap-3 mb-4">
            <input type="color" id="color-picker" value="#ffffff" onchange="updateColor(this.value)">
            <div class="flex-1">
              <div class="text-xs text-gray-400 mb-1">Current</div>
              <div id="current-color" class="text-sm font-mono">#FFFFFF</div>
            </div>
          </div>
          <div class="grid grid-cols-5 gap-2">
            <div class="color-swatch" style="background: #ffffff" onclick="selectColor('#ffffff')"></div>
            <div class="color-swatch" style="background: #000000" onclick="selectColor('#000000')"></div>
            <div class="color-swatch" style="background: #ff0000" onclick="selectColor('#ff0000')"></div>
            <div class="color-swatch" style="background: #00ff00" onclick="selectColor('#00ff00')"></div>
            <div class="color-swatch" style="background: #0000ff" onclick="selectColor('#0000ff')"></div>
            <div class="color-swatch" style="background: #ffff00" onclick="selectColor('#ffff00')"></div>
            <div class="color-swatch" style="background: #ff00ff" onclick="selectColor('#ff00ff')"></div>
            <div class="color-swatch" style="background: #00ffff" onclick="selectColor('#00ffff')"></div>
            <div class="color-swatch" style="background: #ff8800" onclick="selectColor('#ff8800')"></div>
            <div class="color-swatch" style="background: #8800ff" onclick="selectColor('#8800ff')"></div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Brush Settings</h3>
          <div class="space-y-4">
            <div>
              <div class="flex justify-between text-xs text-gray-400 mb-2">
                <span>Size</span>
                <span id="size-value">5</span>
              </div>
              <input type="range" class="slider" id="brush-size" min="1" max="50" value="5" oninput="updateBrushSize(this.value)">
            </div>
            <div>
              <div class="flex justify-between text-xs text-gray-400 mb-2">
                <span>Opacity</span>
                <span id="opacity-value">100%</span>
              </div>
              <input type="range" class="slider" id="brush-opacity" min="0" max="100" value="100" oninput="updateOpacity(this.value)">
            </div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <!-- Removed auto-advance behavior from onion skinning -->
        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Onion Skinning</h3>
          <label class="flex items-center gap-2 cursor-pointer mb-3">
            <input type="checkbox" id="onion-skin-prev" onchange="toggleOnionSkin()" class="w-4 h-4" checked>
            <span class="text-sm">Show Previous Frame</span>
          </label>
          <div id="onion-controls" style="display: block;">
            <div class="flex justify-between text-xs text-gray-400 mb-2">
              <span>Onion Opacity</span>
              <span id="onion-opacity-value">30%</span>
            </div>
            <input type="range" class="slider" id="onion-opacity" min="5" max="80" value="30" oninput="updateOnionOpacity(this.value)">
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Frame Actions</h3>
          <div class="flex flex-col gap-2">
            <button class="tool-btn" onclick="clearCurrentFrame()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
              </svg>
              Clear Frame
            </button>
            <button class="tool-btn" onclick="duplicateFrame()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
              </svg>
              Duplicate Frame
            </button>
            <button class="tool-btn" onclick="clearAllFrames()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"/>
              </svg>
              Clear All Frames
            </button>
          </div>
        </div>
      </div>

      <!-- Center - Canvas Area -->
      <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Canvas Grid -->
        <div class="flex-1 overflow-auto p-6">
          <!-- Improved responsive grid layout -->
          <div class="canvas-grid">
            <div class="canvas-container active" id="frame-container-0">
              <div class="frame-number" id="frame-label-0">Frame 1 - Layer 1</div>
              <canvas id="canvas-0" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-0" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-1">
              <div class="frame-number" id="frame-label-1">Frame 2 - Layer 1</div>
              <canvas id="canvas-1" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-1" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-2">
              <div class="frame-number" id="frame-label-2">Frame 3 - Layer 1</div>
              <canvas id="canvas-2" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-2" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-3">
              <div class="frame-number" id="frame-label-3">Frame 4 - Layer 1</div>
              <canvas id="canvas-3" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-3" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-4">
              <div class="frame-number" id="frame-label-4">Frame 5 - Layer 1</div>
              <canvas id="canvas-4" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-4" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-5">
              <div class="frame-number" id="frame-label-5">Frame 6 - Layer 1</div>
              <canvas id="canvas-5" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-5" width="300" height="300"></canvas>
            </div>
          </div>

          <!-- Animation Preview -->
          <div class="mt-8 max-w-6xl mx-auto">
            <div class="panel">
              <div class="flex items-center justify-between mb-4">
                <h3 class="text-sm font-semibold text-white">Animation Preview</h3>
                <div class="flex items-center gap-3">
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400">FPS:</span>
                    <input type="number" id="fps-input" value="12" min="1" max="60" class="w-16 bg-[#1a1a1a] border border-[#2a2a2a] rounded px-2 py-1 text-sm" onchange="updateFPS(this.value)">
                  </div>
                  <button class="tool-btn" id="play-btn" onclick="toggleAnimation()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                      <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Play
                  </button>
                </div>
              </div>
          <div class="flex justify-center mb-2">
            <div class="text-xs text-gray-400">
              Duration: <span id="total-duration" class="text-white font-mono">0.5s</span>
            </div>
          </div>
          <div class="flex justify-center">
            <div class="canvas-container" id="preview-container" style="max-width: 300px;">
              <canvas id="preview-canvas"></canvas>
            </div>
          </div>
            </div>
          </div>
        </div>

        <!-- Timeline -->
        <div class="panel border-t border-[#2a2a2a] rounded-none">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Timeline</h3>
            <div class="flex items-center gap-2">
              <button class="tool-btn text-xs py-1" onclick="previousFrame()">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                  <polygon points="15 18 9 12 15 6"/>
                </svg>
              </button>
              <button class="tool-btn text-xs py-1" onclick="nextFrame()">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                  <polygon points="9 18 15 12 9 6"/>
                </svg>
              </button>
            </div>
          </div>
          
          <!-- Interactive Timeline Ruler -->
          <div class="mb-4">
            <div class="text-xs text-gray-400 mb-2">Timeline Ruler</div>
            <div class="relative bg-[#1a1a1a] border border-[#2a2a2a] rounded p-2" style="height: 60px; overflow: hidden;">
              <div id="timeline-ruler" class="relative h-full cursor-pointer" style="min-width: 100%;" onmousedown="startTimelineScrub(event)" onmousemove="updateTimelineHover(event)" onmouseleave="hideTimelineHover()">
                <!-- Interactive ruler will be generated by JavaScript -->
              </div>
              <!-- Scrubber line -->
              <div id="timeline-scrubber" class="absolute top-0 bottom-0 w-0.5 bg-[#6366f1] pointer-events-none" style="left: 0px; z-index: 20; box-shadow: 0 0 4px rgba(99, 102, 241, 0.5);">
                <!-- Scrubber handle -->
                <div class="absolute -top-1 -left-1 w-3 h-3 bg-[#6366f1] border border-white rounded-full" style="box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);"></div>
              </div>
              <!-- Time display -->
              <div id="timeline-time-display" class="absolute top-1 right-1 bg-[#1a1a1a] border border-[#6366f1] rounded px-2 py-1 text-xs text-white font-mono pointer-events-none" style="z-index: 30; display: none;">
                0.0s
              </div>
            </div>
          </div>
          
          <div id="timeline-container" class="flex gap-2 pb-6 timeline-scroll" style="width: 100%; overflow-x: auto; overflow-y: hidden; min-width: 0; scroll-behavior: smooth; scrollbar-gutter: stable;">
            <div class="timeline-frame-container">
              <div class="timeline-frame active" id="timeline-0" onclick="selectFrame(0)">
                <canvas width="60" height="60" id="thumb-0" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-0">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-0" onmousedown="startRibDrag(event, 0, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-0" onmousedown="startRibDrag(event, 0, 'right')"></div>
            </div>
            <div class="timeline-frame-container">
              <div class="timeline-frame" id="timeline-1" onclick="selectFrame(1)">
                <canvas width="60" height="60" id="thumb-1" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-1">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-1" onmousedown="startRibDrag(event, 1, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-1" onmousedown="startRibDrag(event, 1, 'right')"></div>
            </div>
            <div class="timeline-frame-container">
              <div class="timeline-frame" id="timeline-2" onclick="selectFrame(2)">
                <canvas width="60" height="60" id="thumb-2" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-2">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-2" onmousedown="startRibDrag(event, 2, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-2" onmousedown="startRibDrag(event, 2, 'right')"></div>
            </div>
            <div class="timeline-frame-container">
              <div class="timeline-frame" id="timeline-3" onclick="selectFrame(3)">
                <canvas width="60" height="60" id="thumb-3" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-3">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-3" onmousedown="startRibDrag(event, 3, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-3" onmousedown="startRibDrag(event, 3, 'right')"></div>
            </div>
            <div class="timeline-frame-container">
              <div class="timeline-frame" id="timeline-4" onclick="selectFrame(4)">
                <canvas width="60" height="60" id="thumb-4" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-4">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-4" onmousedown="startRibDrag(event, 4, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-4" onmousedown="startRibDrag(event, 4, 'right')"></div>
            </div>
            <div class="timeline-frame-container">
              <div class="timeline-frame" id="timeline-5" onclick="selectFrame(5)">
                <canvas width="60" height="60" id="thumb-5" style="width: 100%; height: 100%; object-fit: cover;"></canvas>
                <div class="frame-duration-indicator" id="duration-5">1x</div>
              </div>
              <div class="timeline-rib timeline-rib-left" id="rib-left-5" onmousedown="startRibDrag(event, 5, 'left')"></div>
              <div class="timeline-rib timeline-rib-right" id="rib-right-5" onmousedown="startRibDrag(event, 5, 'right')"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Added sidebar-right class for mobile responsiveness -->
      <!-- Right Sidebar - History & Info -->
      <div class="w-64 panel border-l border-[#2a2a2a] rounded-none flex flex-col gap-6 overflow-y-auto sidebar-right" id="right-sidebar">
        <div>
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Layers</h3>
            <button class="tool-btn text-xs py-1 px-2" onclick="addLayer()">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"/>
                <line x1="5" y1="12" x2="19" y2="12"/>
              </svg>
            </button>
          </div>
          <div class="text-xs text-gray-400 mb-3 p-2 bg-[#1a1a1a] rounded border border-[#2a2a2a]">
            üí° Each layer animates independently. Draw different animations on different layers to create complex scenes!
          </div>
          <div id="layers-list" class="space-y-2 mb-3">
            <!-- Layers will be dynamically added here -->
          </div>
          <div class="flex gap-2">
            <button class="tool-btn flex-1 text-xs" onclick="previewCurrentLayer()" title="Preview only this layer's animation">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
              </svg>
              Preview Layer
            </button>
            <button class="tool-btn flex-1 text-xs" onclick="duplicateLayerToAllFrames()" title="Copy this layer to all frames">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
              </svg>
              Copy to All
            </button>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">History</h3>
          <div class="flex gap-2">
            <button class="tool-btn flex-1" onclick="undo()" id="undo-btn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 7v6h6"/>
                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
              </svg>
              Undo
            </button>
            <button class="tool-btn flex-1" onclick="redo()" id="redo-btn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 7v6h-6"/>
                <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/>
              </svg>
              Redo
            </button>
          </div>
          <div class="text-xs text-gray-500 mt-2">
            <div class="kbd inline">Ctrl+Z</div> / <div class="kbd inline">Ctrl+Y</div> / <div class="kbd inline">Cmd+Shift+Z</div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Keyboard Shortcuts</h3>
          <div class="space-y-2 text-xs">
            <div class="flex justify-between">
              <span class="text-gray-400">Brush</span>
              <span class="kbd">B</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Pencil</span>
              <span class="kbd">P</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Eraser</span>
              <span class="kbd">E</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Fill</span>
              <span class="kbd">F</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Lasso</span>
              <span class="kbd">L</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Next Frame</span>
              <span class="kbd">‚Üí</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Prev Frame</span>
              <span class="kbd">‚Üê</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Play/Pause</span>
              <span class="kbd">Space</span>
            </div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Canvas Info</h3>
          <div class="space-y-2 text-xs">
            <div class="flex justify-between">
              <span class="text-gray-400">Dimensions</span>
              <span class="text-white">300 √ó 300</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Total Frames</span>
              <span class="text-white">6</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Current Frame</span>
              <span class="text-white" id="current-frame-info">1</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar flex items-center justify-between">
      <div class="flex items-center gap-4">
        <span id="status-text">Ready</span>
      </div>
      <div>Studio Frame v1.0</div>
    </div>
  </div>

  <script>
    const canvases = [];
    const contexts = [];
    const onionCanvases = [];
    const onionContexts = [];
    const thumbCanvases = [];
    const thumbContexts = [];
    const history = [];
    const redoStack = [];
    
    const frameLayers = Array(6).fill(null).map(() => []);
    let currentLayer = 0;
    
    // Frame duration system - each frame has a duration in "time units"
    const frameDurations = [1, 1, 1, 1, 1, 1]; // Default: each frame shows for 1 time unit
    let currentFrame = 0;
    let currentTool = 'brush';
    let currentColor = '#ffffff';
    let brushSize = 5;
    let brushOpacity = 1;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let animationInterval = null;
    let animationFrame = 0;
    let fps = 12;
    let onionSkinEnabled = true;
    let onionOpacity = 0.3;
    let lassoPoints = [];
    let isLassoActive = false;
    let isPreviewingLayer = false;
    let previewLayerIndex = -1;
    let lassoOverlayCanvas = null;
    let lassoOverlayCtx = null;
    /* Changed initial viewport to phone */
    let currentViewport = 'phone';
    /* Added zoom levels array for each frame */
    const zoomLevels = [1, 1, 1, 1, 1, 1];
    
    // Timeline drag functionality
    let isDraggingRib = false;
    let dragFrameIndex = -1;
    let dragSide = '';
    let dragStartX = 0;
    let dragStartDuration = 0;

    const layerColors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444', '#06b6d4', '#84cc16'];

    for (let i = 0; i < 6; i++) {
      const layerCanvas = document.createElement('canvas');
      /* Reduced initial canvas size to phone dimensions (smaller) */
      layerCanvas.width = 240;
      layerCanvas.height = 427;
      const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
      frameLayers[i].push({
        canvas: layerCanvas,
        ctx: layerCtx,
        visible: true,
        name: 'Layer 1',
        opacity: 1,
        color: layerColors[0]
      });
    }

    // Initialize canvases
    for (let i = 0; i < 6; i++) {
      const canvas = document.getElementById(`canvas-${i}`);
      /* Reduced initial canvas dimensions to smaller phone size */
      canvas.width = 240;
      canvas.height = 427;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      canvases.push(canvas);
      contexts.push(ctx);

      const onionCanvas = document.getElementById(`onion-${i}`);
      /* Reduced initial onion canvas dimensions to smaller phone size */
      onionCanvas.width = 240;
      onionCanvas.height = 427;
      const onionCtx = onionCanvas.getContext('2d');
      onionCanvases.push(onionCanvas);
      onionContexts.push(onionCtx);

      const thumbCanvas = document.getElementById(`thumb-${i}`);
      const thumbCtx = thumbCanvas.getContext('2d');
      thumbCtx.fillStyle = '#1a1a1a';
      thumbCtx.fillRect(0, 0, thumbCanvas.width, thumbCanvas.height);
      thumbCanvases.push(thumbCanvas);
      thumbContexts.push(thumbCtx);

      canvas.addEventListener('mousedown', (e) => {
        const frameIndex = canvases.indexOf(e.target);
        if (frameIndex !== currentFrame) {
          selectFrame(frameIndex);
        }
        startDrawing(e);
      });
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseleave', stopDrawing);
      
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
      });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
      });
      
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        canvas.dispatchEvent(mouseEvent);
      });
      
      /* Added wheel event listener for zoom functionality */
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const frameIndex = canvases.indexOf(e.target);
        handleZoom(e, frameIndex);
      });
    }

    // Preview canvas
    const previewCanvas = document.getElementById('preview-canvas');
    /* Reduced initial preview canvas dimensions to smaller phone size */
    previewCanvas.width = 240;
    previewCanvas.height = 427;
    const previewCtx = previewCanvas.getContext('2d');
    previewCtx.fillStyle = '#1a1a1a';
    previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
    
    // Set initial preview container aspect ratio
    const previewContainer = document.getElementById('preview-container');
    if (previewContainer) {
      previewContainer.style.setProperty('--canvas-aspect-ratio', '9 / 16');
    }

    /* Added zoom handler function */
    function handleZoom(e, frameIndex) {
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      // Limit zoom to not go below 1.0 (actual canvas size) and max 3.0
      zoomLevels[frameIndex] = Math.max(1.0, Math.min(3.0, zoomLevels[frameIndex] + delta));
      
      const canvas = canvases[frameIndex];
      const onionCanvas = onionCanvases[frameIndex];
      const container = canvas.parentElement;
      
      // Apply zoom with proper centering
      canvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      onionCanvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      
      // Ensure the canvas stays within the container bounds
      const containerRect = container.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      // If zoomed out too much, reset to minimum zoom
      if (zoomLevels[frameIndex] < 1.0) {
        zoomLevels[frameIndex] = 1.0;
        canvas.style.transform = 'scale(1)';
        onionCanvas.style.transform = 'scale(1)';
      }
    }

    /* Added viewport switching function */
    function setViewport(mode) {
      currentViewport = mode;
      const containers = document.querySelectorAll('.canvas-container');
      
      document.getElementById('desktop-btn').classList.toggle('active', mode === 'desktop');
      document.getElementById('phone-btn').classList.toggle('active', mode === 'phone');
      
      // Reset zoom levels when switching viewports
      zoomLevels.fill(1.0);
      
      if (mode === 'desktop') {
        // Desktop: 16:9 aspect ratio
        containers.forEach(container => {
          container.style.setProperty('--canvas-aspect-ratio', '16 / 9');
        });
        
        /* Reduced desktop canvas dimensions */
        // Update canvas dimensions
        canvases.forEach((canvas, i) => {
          canvas.width = 427;
          canvas.height = 240;
          onionCanvases[i].width = 427;
          onionCanvases[i].height = 240;
          // Reset zoom transform
          canvas.style.transform = 'scale(1)';
          onionCanvases[i].style.transform = 'scale(1)';
        });
        
        // Update layer canvases
        frameLayers.forEach(layers => {
          layers.forEach(layer => {
            const oldCanvas = layer.canvas;
            const newCanvas = document.createElement('canvas');
            newCanvas.width = 427;
            newCanvas.height = 240;
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            newCtx.drawImage(oldCanvas, 0, 0, oldCanvas.width, oldCanvas.height, 0, 0, 427, 240);
            layer.canvas = newCanvas;
            layer.ctx = newCtx;
          });
        });
        
        previewCanvas.width = 427;
        previewCanvas.height = 240;
        // Set preview container aspect ratio for desktop
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.style.setProperty('--canvas-aspect-ratio', '16 / 9');
        }
      } else {
        // Phone: 9:16 aspect ratio
        containers.forEach(container => {
          container.style.setProperty('--canvas-aspect-ratio', '9 / 16');
        });
        
        /* Reduced phone canvas dimensions */
        // Update canvas dimensions
        canvases.forEach((canvas, i) => {
          canvas.width = 240;
          canvas.height = 427;
          onionCanvases[i].width = 240;
          onionCanvases[i].height = 427;
          // Reset zoom transform
          canvas.style.transform = 'scale(1)';
          onionCanvases[i].style.transform = 'scale(1)';
        });
        
        // Update layer canvases
        frameLayers.forEach(layers => {
          layers.forEach(layer => {
            const oldCanvas = layer.canvas;
            const newCanvas = document.createElement('canvas');
            newCanvas.width = 240;
            newCanvas.height = 427;
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            newCtx.drawImage(oldCanvas, 0, 0, oldCanvas.width, oldCanvas.height, 0, 0, 240, 427);
            layer.canvas = newCanvas;
            layer.ctx = newCtx;
          });
        });
        
        previewCanvas.width = 240;
        previewCanvas.height = 427;
        // Set preview container aspect ratio for phone
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.style.setProperty('--canvas-aspect-ratio', '9 / 16');
        }
      }
      
      // Redraw all frames
      for (let i = 0; i < 6; i++) {
        composeLayers(i);
        updateThumbnail(i);
      }
      
      updateOnionSkin();
    }

    function saveState() {
      const state = {
        frameLayers: frameLayers.map(layers => layers.map(layer => layer.canvas.toDataURL())),
        onionSkinEnabled: onionSkinEnabled
      };
      history.push(state);
      if (history.length > 50) history.shift();
      redoStack.length = 0;
      updateHistoryButtons();
    }

    function undo() {
      if (history.length > 1) {
        redoStack.push(history.pop());
        const state = history[history.length - 1];
        restoreState(state);
        updateHistoryButtons();
      }
    }

    function redo() {
      if (redoStack.length > 0) {
        const state = redoStack.pop();
        history.push(state);
        restoreState(state);
        updateHistoryButtons();
      }
    }

    function restoreState(state) {
      // Handle both old format (array) and new format (object)
      let frameLayersData, onionSkinState;
      
      if (Array.isArray(state)) {
        // Old format - just frame layers, keep current onion skin state
        frameLayersData = state;
        onionSkinState = onionSkinEnabled;
      } else {
        // New format - object with frame layers and onion skin state
        frameLayersData = state.frameLayers;
        onionSkinState = state.onionSkinEnabled;
      }
      
      frameLayersData.forEach((layersDataURL, frameIndex) => {
        layersDataURL.forEach((dataURL, layerIndex) => {
          const img = new Image();
          img.onload = () => {
            const layer = frameLayers[frameIndex][layerIndex];
            layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            layer.ctx.drawImage(img, 0, 0);
            if (frameIndex === currentFrame) {
              composeLayers();
              updateThumbnail(frameIndex);
            }
          };
          img.src = dataURL;
        });
      });
      
      // Restore onion skin state if it was different
      if (onionSkinState !== onionSkinEnabled) {
        onionSkinEnabled = onionSkinState;
        updateOnionSkin();
      }
    }

    function updateHistoryButtons() {
      document.getElementById('undo-btn').disabled = history.length <= 1;
      document.getElementById('redo-btn').disabled = redoStack.length === 0;
    }

    function selectFrame(index) {
      // Clean up lasso overlay when switching frames
      if (lassoOverlayCanvas) {
        lassoOverlayCanvas.remove();
        lassoOverlayCanvas = null;
        lassoOverlayCtx = null;
        isLassoActive = false;
        lassoPoints = [];
      }
      
      currentFrame = index;
      document.querySelectorAll('.canvas-container').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      document.querySelectorAll('.timeline-frame').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      document.getElementById('current-frame-info').textContent = index + 1;
      updateLayersList();
      updateOnionSkin();
      updateFrameLabel();
      updateTimelineRuler();
    }

    function setTool(tool) {
      // Clean up lasso overlay if switching away from lasso
      if (currentTool === 'lasso' && lassoOverlayCanvas) {
        lassoOverlayCanvas.remove();
        lassoOverlayCanvas = null;
        lassoOverlayCtx = null;
        isLassoActive = false;
        lassoPoints = [];
      }
      
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(`${tool}-btn`).classList.add('active');
      document.getElementById('status-text').textContent = `Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`;
    }

    function updateColor(color) {
      currentColor = color;
      document.getElementById('current-color').textContent = color.toUpperCase();
    }

    function selectColor(color) {
      currentColor = color;
      document.getElementById('color-picker').value = color;
      document.getElementById('current-color').textContent = color.toUpperCase();
    }

    function updateBrushSize(size) {
      brushSize = parseInt(size);
      document.getElementById('size-value').textContent = size;
    }

    function updateOpacity(opacity) {
      brushOpacity = opacity / 100;
      document.getElementById('opacity-value').textContent = opacity + '%';
    }

    function updateOnionOpacity(opacity) {
      onionOpacity = opacity / 100;
      document.getElementById('onion-opacity-value').textContent = opacity + '%';
      updateOnionSkin();
    }

    function updateFPS(newFps) {
      fps = parseInt(newFps);
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = setInterval(updateAnimation, 1000 / fps);
      }
      // Update time scale indicators when FPS changes
      updateAllTimeScaleIndicators();
    }

    function getCanvasCoordinates(canvas, clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      // Calculate the scale factor between displayed size and actual canvas size
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      // Get position relative to canvas and scale to actual canvas coordinates
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      
      return { x, y };
    }

    function startDrawing(e) {
      const canvas = e.target;
      const frameIndex = canvases.indexOf(canvas);
      if (frameIndex !== currentFrame) return;

      isDrawing = true;
      const coords = getCanvasCoordinates(canvas, e.clientX, e.clientY);
      lastX = coords.x;
      lastY = coords.y;

      if (currentTool === 'lasso') {
        lassoPoints = [[lastX, lastY]];
        isLassoActive = true;
        
        // Create overlay canvas for lasso trail
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = canvas.width;
        lassoOverlayCanvas.height = canvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '1000';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        
        container.style.position = 'relative';
        container.appendChild(lassoOverlayCanvas);
      } else if (currentTool === 'fill') {
        floodFill(lastX, lastY);
        composeLayers();
        updateThumbnail(currentFrame);
      } else {
        saveState();
      }
    }

    function draw(e) {
      if (!isDrawing) return;

      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = canvases[currentFrame];
      const coords = getCanvasCoordinates(canvas, e.clientX, e.clientY);
      const x = coords.x;
      const y = coords.y;

      if (currentTool === 'lasso') {
        lassoPoints.push([x, y]);
        // Draw the lasso trail on the overlay canvas
        if (lassoOverlayCtx) {
          lassoOverlayCtx.strokeStyle = '#ffffff';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(lastX, lastY);
          lassoOverlayCtx.lineTo(x, y);
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
      } else if (currentTool === 'brush' || currentTool === 'pencil') {
        ctx.globalAlpha = brushOpacity;
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentTool === 'pencil' ? Math.max(1, brushSize / 2) : brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      }

      lastX = x;
      lastY = y;
      
      composeLayers();
    }

    function stopDrawing() {
      if (!isDrawing) return;
      isDrawing = false;

      if (currentTool === 'lasso' && isLassoActive) {
        // Perform the lasso erase operation first
        eraseLassoSelection();
        
        // Remove the overlay canvas immediately
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        
        isLassoActive = false;
        lassoPoints = [];
      }

      composeLayers();
      updateThumbnail(currentFrame);
      
      /* Automatically show onion skin on next frame after drawing */
      if (onionSkinEnabled && currentFrame < 5) {
        updateOnionSkin();
      }
    }

    function composeLayers(frameIndex) {
      /* Made composeLayers accept optional frameIndex parameter */
      const idx = frameIndex !== undefined ? frameIndex : currentFrame;
      const ctx = contexts[idx];
      const canvas = canvases[idx];
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Use dark background
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      frameLayers[idx].forEach(layer => {
        if (layer.visible) {
          ctx.save();
          ctx.globalAlpha = layer.opacity;
          ctx.drawImage(layer.canvas, 0, 0);
          ctx.restore();
        }
      });
      
      if (frameIndex === undefined) {
        updateThumbnail(idx);
      }
    }

    function eraseLassoSelection() {
      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = layer.canvas;
      
      if (lassoPoints.length < 3) return;

      // Save state before lasso operation
      saveState();
      
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(lassoPoints[0][0], lassoPoints[0][1]);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i][0], lassoPoints[i][1]);
      }
      ctx.closePath();
      ctx.clip();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function floodFill(startX, startY) {
      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = layer.canvas;
      
      // Save state before fill operation
      saveState();
      
      // Fill the entire canvas with the selected color
      ctx.fillStyle = currentColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      composeLayers();
      updateThumbnail(currentFrame);
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 255, g: 255, b: 255 };
    }

    function updateThumbnail(index) {
      const thumbCtx = thumbContexts[index];
      thumbCtx.clearRect(0, 0, 60, 60);
      thumbCtx.fillStyle = '#1a1a1a';
      thumbCtx.fillRect(0, 0, 60, 60);
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 300;
      tempCanvas.height = 300;
      const tempCtx = tempCanvas.getContext('2d');
      
      frameLayers[index].forEach(layer => {
        if (layer.visible) {
          tempCtx.save();
          tempCtx.globalAlpha = layer.opacity;
          tempCtx.drawImage(layer.canvas, 0, 0);
          tempCtx.restore();
        }
      });
      thumbCtx.drawImage(tempCanvas, 0, 0, 300, 300, 0, 0, 60, 60);
      
    }

    function clearCurrentFrame() {
      saveState();
      const layer = frameLayers[currentFrame][currentLayer];
      layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
      composeLayers();
      updateThumbnail(currentFrame);
      updateOnionSkin();
    }

    function duplicateFrame() {
      if (currentFrame < 5) {
        saveState();
        const nextFrame = currentFrame + 1;
        
        frameLayers[nextFrame] = frameLayers[currentFrame].map(layer => {
          const newCanvas = document.createElement('canvas');
          newCanvas.width = layer.canvas.width; // Use current canvas dimensions
          newCanvas.height = layer.canvas.height; // Use current canvas dimensions
          const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
          newCtx.drawImage(layer.canvas, 0, 0);
          
          return {
            canvas: newCanvas,
            ctx: newCtx,
            visible: layer.visible,
            name: layer.name,
            opacity: layer.opacity,
            color: layer.color
          };
        });
        
        composeLayers();
        updateThumbnail(nextFrame);
        selectFrame(nextFrame);
      }
    }

    function clearAllFrames() {
      if (confirm('Clear all frames? This cannot be undone.')) {
        saveState();
        frameLayers.forEach((layers, frameIndex) => {
          layers.forEach(layer => {
            layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
          });
          composeLayers(frameIndex);
          updateThumbnail(frameIndex);
        });
        updateOnionSkin();
      }
    }

    function toggleOnionSkin() {
      onionSkinEnabled = document.getElementById('onion-skin-prev').checked;
      const controls = document.getElementById('onion-controls');
      controls.style.display = onionSkinEnabled ? 'block' : 'none';
      updateOnionSkin();
    }

    function updateOnionSkin() {
      onionContexts.forEach((ctx, i) => {
        ctx.clearRect(0, 0, onionCanvases[i].width, onionCanvases[i].height);
      });

      /* Show onion skin on next frame automatically */
      if (onionSkinEnabled) {
        for (let i = 1; i < 6; i++) {
          const prevFrameIndex = i - 1;
          const onionCtx = onionContexts[i];
          
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvases[i].width;
          tempCanvas.height = canvases[i].height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.fillStyle = '#1a1a1a';
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

          frameLayers[prevFrameIndex].forEach(layer => {
            if (layer.visible) {
              tempCtx.save();
              tempCtx.globalAlpha = layer.opacity;
              tempCtx.drawImage(layer.canvas, 0, 0);
              tempCtx.restore();
            }
          });
          
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixels = imageData.data;
          
          const bgColor = hexToRgb('#1a1a1a');
          for (let j = 0; j < pixels.length; j += 4) {
            const r = pixels[j];
            const g = pixels[j + 1];
            const b = pixels[j + 2];
            const a = pixels[j + 3];
            
            const isBg = Math.abs(r - bgColor.r) < 10 && 
                         Math.abs(g - bgColor.g) < 10 && 
                         Math.abs(b - bgColor.b) < 10;
            
            if (!isBg && a > 0) {
              pixels[j] = Math.min(255, r * 0.7 + 255 * 0.3);
              pixels[j + 1] = Math.min(255, g * 0.7 + 105 * 0.3);
              pixels[j + 2] = Math.min(255, b * 0.7 + 180 * 0.3);
              pixels[j + 3] = a * onionOpacity;
            } else {
              pixels[j + 3] = 0;
            }
          }
          
          tempCtx.putImageData(imageData, 0, 0);
          onionCtx.drawImage(tempCanvas, 0, 0);
        }
      }
    }

    function previousFrame() {
      if (currentFrame > 0) {
        selectFrame(currentFrame - 1);
      }
    }

    function nextFrame() {
      if (currentFrame < 5) {
        selectFrame(currentFrame + 1);
      }
    }

    function previewCurrentLayer() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
          Play
        `;
        return;
      }

      isPreviewingLayer = true;
      previewLayerIndex = currentLayer;
      animationFrame = 0;
      currentFrameTime = 0;
      currentFrameDuration = frameDurations[0];
      
      animationInterval = setInterval(() => {
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.fillStyle = '#1a1a1a';
        previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        const layer = frameLayers[animationFrame][previewLayerIndex];
        if (layer && layer.visible) {
          previewCtx.save();
          previewCtx.globalAlpha = layer.opacity;
          // Draw the layer canvas at full size to fill the preview canvas exactly
          previewCtx.drawImage(layer.canvas, 0, 0, previewCanvas.width, previewCanvas.height);
          previewCtx.restore();
        }

        // Update animation timing based on frame durations
        currentFrameTime++;
        if (currentFrameTime >= currentFrameDuration) {
          animationFrame = (animationFrame + 1) % 6;
          currentFrameTime = 0;
          currentFrameDuration = frameDurations[animationFrame];
        }
      }, 1000 / fps);
      
      document.getElementById('play-btn').innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <rect x="6" y="4" width="4" height="16"/>
          <rect x="14" y="4" width="4" height="16"/>
        </svg>
        Pause
      `;
    }

    function duplicateLayerToAllFrames() {
      if (!confirm('Copy the current layer from this frame to all other frames? This will overwrite existing content on this layer in other frames.')) {
        return;
      }
      
      saveState();
      const sourceLayer = frameLayers[currentFrame][currentLayer];
      
      for (let frameIndex = 0; frameIndex < 6; frameIndex++) {
        if (frameIndex === currentFrame) continue;
        
        while (frameLayers[frameIndex].length <= currentLayer) {
          const layerCanvas = document.createElement('canvas');
          layerCanvas.width = canvases[frameIndex].width;
          layerCanvas.height = canvases[frameIndex].height;
          const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
          
          const layerIndex = frameLayers[frameIndex].length;
          frameLayers[frameIndex].push({
            canvas: layerCanvas,
            ctx: layerCtx,
            visible: true,
            name: `Layer ${layerIndex + 1}`,
            opacity: 1,
            color: layerColors[layerIndex % layerColors.length]
          });
        }
        
        const targetLayer = frameLayers[frameIndex][currentLayer];
        targetLayer.ctx.clearRect(0, 0, targetLayer.canvas.width, targetLayer.canvas.height);
        targetLayer.ctx.drawImage(sourceLayer.canvas, 0, 0);
        targetLayer.visible = sourceLayer.visible;
        targetLayer.opacity = sourceLayer.opacity;
        
        composeLayers(frameIndex);
        updateThumbnail(frameIndex);
      }
      
      alert('Layer copied to all frames! Now you can add another animation on a new layer.');
    }

    function toggleAnimation() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
          Play
        `;
      } else {
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        animationFrame = 0;
        currentFrameTime = 0;
        currentFrameDuration = frameDurations[0];
        animationInterval = setInterval(updateAnimation, 1000 / fps);
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          Pause
        `;
      }
    }

    // Animation timing system
    let animationTimeUnit = 0;
    let currentFrameTime = 0;
    let currentFrameDuration = 1;

    function updateAnimation() {
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = '#1a1a1a';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Draw all layers for the current animation frame
      frameLayers[animationFrame].forEach(layer => {
        if (layer.visible) {
          previewCtx.save();
          previewCtx.globalAlpha = layer.opacity;
          // Draw the layer canvas at full size to fill the preview canvas exactly
          previewCtx.drawImage(layer.canvas, 0, 0, previewCanvas.width, previewCanvas.height);
          previewCtx.restore();
        }
      });

      // Update animation timing based on frame durations
      currentFrameTime++;
      if (currentFrameTime >= currentFrameDuration) {
        animationFrame = (animationFrame + 1) % 6;
        currentFrameTime = 0;
        currentFrameDuration = frameDurations[animationFrame];
      }
    }

    async function exportAnimation() {
      try {
        // Show loading state
        document.getElementById('status-text').textContent = 'Preparing video export...';
        
        // Check if FFmpeg is available
        if (typeof FFmpeg === 'undefined' && typeof window.FFmpeg === 'undefined') {
          // Try MediaRecorder API first, then fallback to images
          document.getElementById('status-text').textContent = 'FFmpeg not available, trying alternative export...';
          try {
            await exportWithMediaRecorder();
            return;
          } catch (error) {
            console.log('MediaRecorder failed, falling back to image export:', error);
            await exportFramesAsImages();
            return;
          }
        }
        
        // Use window.FFmpeg if available, otherwise use global FFmpeg
        const FFmpegLib = window.FFmpeg || FFmpeg;
        
        // Create frames array with proper timing
        const frames = [];
        for (let i = 0; i < 6; i++) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvases[i].width;
          tempCanvas.height = canvases[i].height;
          const tempCtx = tempCanvas.getContext('2d');
          
          // Fill background
          tempCtx.fillStyle = '#1a1a1a';
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
          
          // Draw all layers for this frame
          frameLayers[i].forEach(layer => {
            if (layer.visible) {
              tempCtx.save();
              tempCtx.globalAlpha = layer.opacity;
              tempCtx.drawImage(layer.canvas, 0, 0);
              tempCtx.restore();
            }
          });
          
          // Add frame multiple times based on duration
          const frameDuration = frameDurations[i];
          const frameData = tempCanvas.toDataURL('image/png');
          
          // Add the frame multiple times to match its duration
          for (let j = 0; j < Math.max(1, Math.round(frameDuration)); j++) {
            frames.push(frameData);
          }
        }
        
        // Convert frames to video using FFmpeg
        const { createFFmpeg, fetchFile } = FFmpegLib;
        const ffmpeg = createFFmpeg({ 
          log: true,
          corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js',
          wasmPath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.wasm'
        });
        
        document.getElementById('status-text').textContent = 'Loading FFmpeg...';
        
        // Add timeout for FFmpeg loading
        const loadPromise = ffmpeg.load();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('FFmpeg loading timeout')), 30000)
        );
        
        await Promise.race([loadPromise, timeoutPromise]);
        
        document.getElementById('status-text').textContent = 'Processing frames...';
        
        // Write frame files
        for (let i = 0; i < frames.length; i++) {
          const frameData = await fetchFile(frames[i]);
          ffmpeg.FS('writeFile', `frame${i.toString().padStart(3, '0')}.png`, frameData);
        }
        
        document.getElementById('status-text').textContent = 'Creating MP4 video...';
        
        // Calculate total duration and effective framerate
        const totalDuration = frameDurations.reduce((sum, duration) => sum + duration, 0);
        const effectiveFramerate = totalDuration / (totalDuration / fps);
        
        // Run FFmpeg command to create video
        await ffmpeg.run(
          '-framerate', fps.toString(),
          '-i', 'frame%03d.png',
          '-c:v', 'libx264',
          '-pix_fmt', 'yuv420p',
          '-y',
          'output.mp4'
        );
        
        // Get the output video
        const videoData = ffmpeg.FS('readFile', 'output.mp4');
        const videoBlob = new Blob([videoData.buffer], { type: 'video/mp4' });
        const videoUrl = URL.createObjectURL(videoBlob);
        
        // Download the video
        const link = document.createElement('a');
        link.download = `animation-${Date.now()}.mp4`;
        link.href = videoUrl;
        link.click();
        
        // Cleanup
        URL.revokeObjectURL(videoUrl);
        ffmpeg.exit();
        
        document.getElementById('status-text').textContent = 'MP4 video exported successfully!';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 2000);
        
      } catch (error) {
        console.error('Export failed:', error);
        let errorMessage = 'Export failed. Please try again.';
        
        if (error.message.includes('FFmpeg library not loaded')) {
          errorMessage = 'FFmpeg library not loaded. Please refresh the page and try again.';
        } else if (error.message.includes('loading timeout')) {
          errorMessage = 'FFmpeg loading timeout. Please check your internet connection and try again.';
        } else if (error.message.includes('load')) {
          errorMessage = 'Failed to load FFmpeg. Please check your internet connection and try again.';
        } else if (error.message.includes('run')) {
          errorMessage = 'Failed to process video. Please try again.';
        }
        
        document.getElementById('status-text').textContent = errorMessage;
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 5000);
      }
    }

    // Export using MediaRecorder API (WebM format)
    async function exportWithMediaRecorder() {
      return new Promise((resolve, reject) => {
        try {
          // Create a canvas for recording
          const recordCanvas = document.createElement('canvas');
          recordCanvas.width = canvases[0].width;
          recordCanvas.height = canvases[0].height;
          const recordCtx = recordCanvas.getContext('2d');
          
          // Create a stream from the canvas
          const stream = recordCanvas.captureStream(60); // 60 FPS
          
          // Create MediaRecorder
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/mp4'
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              chunks.push(event.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `animation-${Date.now()}.mp4`;
            link.click();
            URL.revokeObjectURL(url);
            document.getElementById('status-text').textContent = 'MP4 video exported successfully!';
            setTimeout(() => {
              document.getElementById('status-text').textContent = 'Ready';
            }, 2000);
            resolve();
          };
          
          mediaRecorder.onerror = (error) => {
            reject(error);
          };
          
          // Start recording
          mediaRecorder.start();
          
          // Animate frames with proper timing
          let frameIndex = 0;
          const animate = () => {
            // Clear canvas
            recordCtx.fillStyle = '#1a1a1a';
            recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
            
            // Draw current frame
            frameLayers[frameIndex].forEach(layer => {
              if (layer.visible) {
                recordCtx.save();
                recordCtx.globalAlpha = layer.opacity;
                recordCtx.drawImage(layer.canvas, 0, 0);
                recordCtx.restore();
              }
            });
            
            frameIndex++;
            if (frameIndex < 6) {
              // Use frame duration for timing
              const frameDuration = frameDurations[frameIndex - 1];
              const delay = (frameDuration / fps) * 1000; // Convert to milliseconds
              setTimeout(animate, delay);
            } else {
              // Stop recording after all frames
              const lastFrameDuration = frameDurations[frameIndex - 1];
              const delay = (lastFrameDuration / fps) * 1000;
              setTimeout(() => {
                mediaRecorder.stop();
              }, delay);
            }
          };
          
          animate();
          
        } catch (error) {
          reject(error);
        }
      });
    }

    // Fallback function to export frames as individual images
    async function exportFramesAsImages() {
      try {
        const zip = new JSZip();
        
        for (let i = 0; i < 6; i++) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvases[i].width;
          tempCanvas.height = canvases[i].height;
          const tempCtx = tempCanvas.getContext('2d');
          
          // Fill background
          tempCtx.fillStyle = '#1a1a1a';
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
          
          // Draw all layers for this frame
          frameLayers[i].forEach(layer => {
            if (layer.visible) {
              tempCtx.save();
              tempCtx.globalAlpha = layer.opacity;
              tempCtx.drawImage(layer.canvas, 0, 0);
              tempCtx.restore();
            }
          });
          
          // Convert to blob and add to zip
          const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
          zip.file(`frame_${i + 1}.png`, blob);
        }
        
        // Generate and download zip
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `animation-frames-${Date.now()}.zip`;
        link.click();
        URL.revokeObjectURL(url);
        
        document.getElementById('status-text').textContent = 'Frames exported as images!';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 2000);
        
      } catch (error) {
        console.error('Frame export failed:', error);
        document.getElementById('status-text').textContent = 'Export failed. Please try again.';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 3000);
      }
    }

    document.addEventListener('keydown', (e) => {
      // Debug logging (remove in production)
      if (e.ctrlKey || e.metaKey) {
        console.log('Key pressed:', e.key, 'Shift:', e.shiftKey, 'Ctrl:', e.ctrlKey, 'Meta:', e.metaKey);
      }
      
      if (e.ctrlKey || e.metaKey) {
        // Handle undo (Cmd+Z or Ctrl+Z)
        if ((e.key === 'z' || e.key === 'Z') && !e.shiftKey) {
          e.preventDefault();
          undo();
        } 
        // Handle redo (Cmd+Shift+Z, Ctrl+Shift+Z, Cmd+Y, or Ctrl+Y)
        else if (e.key === 'y' || e.key === 'Y' || ((e.key === 'z' || e.key === 'Z') && e.shiftKey)) {
          e.preventDefault();
          redo();
        }
      } else {
        switch(e.key.toLowerCase()) {
          case 'b': setTool('brush'); break;
          case 'p': setTool('pencil'); break;
          case 'e': setTool('eraser'); break;
          case 'f': setTool('fill'); break;
          case 'l': setTool('lasso'); break;
          case 'arrowright': nextFrame(); break;
          case 'arrowleft': previousFrame(); break;
          case ' ': e.preventDefault(); toggleAnimation(); break;
        }
      }
    });

    function addLayer() {
      saveState();
      
      const layerIndex = frameLayers[0].length;
      
      for (let frameIndex = 0; frameIndex < 6; frameIndex++) {
        const layerCanvas = document.createElement('canvas');
        layerCanvas.width = canvases[0].width;
        layerCanvas.height = canvases[0].height;
        const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        
        const newLayer = {
          canvas: layerCanvas,
          ctx: layerCtx,
          visible: true,
          name: `Layer ${layerIndex + 1}`,
          opacity: 1,
          color: layerColors[layerIndex % layerColors.length]
        };
        
        frameLayers[frameIndex].push(newLayer);
        
        composeLayers(frameIndex);
        updateThumbnail(frameIndex);
      }
      
      currentLayer = frameLayers[currentFrame].length - 1;
      updateLayersList();
      updateFrameLabel();
      
      for (let i = 0; i < 6; i++) {
        const layer = frameLayers[i][currentLayer];
        const label = document.getElementById(`frame-label-${i}`);
        if (label) {
          label.textContent = `Frame ${i + 1} - ${layer.name}`;
          label.style.color = layer.color;
        }
      }
    }

    function deleteLayer(index) {
      if (frameLayers[currentFrame].length <= 1) {
        alert('Cannot delete the last layer');
        return;
      }
      
      frameLayers[currentFrame].splice(index, 1);
      if (currentLayer >= frameLayers[currentFrame].length) {
        currentLayer = frameLayers[currentFrame].length - 1;
      }
      updateLayersList();
      updateFrameLabel();
      composeLayers();
    }

    function toggleLayerVisibility(index) {
      frameLayers[currentFrame][index].visible = !frameLayers[currentFrame][index].visible;
      updateLayersList();
      composeLayers();
    }

    function selectLayer(index) {
      currentLayer = index;
      updateLayersList();
      updateFrameLabel();
    }

    function updateFrameLabel() {
      const layer = frameLayers[currentFrame][currentLayer];
      const label = document.getElementById(`frame-label-${currentFrame}`);
      if (label) {
        label.textContent = `Frame ${currentFrame + 1} - ${layer.name}`;
        label.style.color = layer.color;
      }
    }

    function updateLayersList() {
      const layersList = document.getElementById('layers-list');
      layersList.innerHTML = '';
      
      for (let i = frameLayers[currentFrame].length - 1; i >= 0; i--) {
        const layer = frameLayers[currentFrame][i];
        const layerItem = document.createElement('div');
        layerItem.className = `layer-item ${i === currentLayer ? 'active' : ''}`;
        layerItem.onclick = () => selectLayer(i);
        
        layerItem.innerHTML = `
          <div style="width: 4px; height: 100%; background: ${layer.color}; border-radius: 2px; position: absolute; left: 0; top: 0;"></div>
          <div class="layer-visibility" onclick="event.stopPropagation(); toggleLayerVisibility(${i})">
            ${layer.visible ? 
              '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>' :
              '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>'
            }
          </div>
          <div class="layer-name" style="color: ${layer.color}">${layer.name}</div>
          <div class="layer-delete" onclick="event.stopPropagation(); deleteLayer(${i})">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </div>
        `;
        
        layersList.appendChild(layerItem);
      }
    }

    /* Added sidebar toggle functions for mobile */
    function toggleLeftSidebar() {
      const sidebar = document.getElementById('left-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const isOpen = sidebar.classList.contains('open');
      
      closeSidebars();
      
      if (!isOpen) {
        sidebar.classList.add('open');
        overlay.classList.add('active');
      }
    }

    function toggleRightSidebar() {
      const sidebar = document.getElementById('right-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const isOpen = sidebar.classList.contains('open');
      
      closeSidebars();
      
      if (!isOpen) {
        sidebar.classList.add('open');
        overlay.classList.add('active');
      }
    }

    function closeSidebars() {
      document.getElementById('left-sidebar').classList.remove('open');
      document.getElementById('right-sidebar').classList.remove('open');
      document.getElementById('sidebar-overlay').classList.remove('active');
    }

    // Timeline rib drag functionality
    function startRibDrag(event, frameIndex, side) {
      event.preventDefault();
      event.stopPropagation();
      
      isDraggingRib = true;
      dragFrameIndex = frameIndex;
      dragSide = side;
      dragStartX = event.clientX;
      dragStartDuration = frameDurations[frameIndex];
      
      // Add visual feedback
      const rib = document.getElementById(`rib-${side}-${frameIndex}`);
      rib.classList.add('dragging');
      
      const container = rib.closest('.timeline-frame-container');
      container.classList.add('dragging');
      
      // Add global event listeners
      document.addEventListener('mousemove', handleRibDrag);
      document.addEventListener('mouseup', stopRibDrag);
    }

    function handleRibDrag(event) {
      if (!isDraggingRib) return;
      
      const deltaX = event.clientX - dragStartX;
      const pixelsPerDuration = 20; // 20 pixels per duration unit
      const durationChange = deltaX / pixelsPerDuration;
      
      let newDuration = dragStartDuration + durationChange;
      // Round to nearest 0.1 increment
      newDuration = Math.round(newDuration * 10) / 10;
      newDuration = Math.max(0.1, Math.min(10, newDuration)); // Limit between 0.1 and 10
      
      frameDurations[dragFrameIndex] = newDuration;
      updateFrameDurationIndicator(dragFrameIndex);
      
      // Update container width in real-time during drag
      const container = document.querySelector(`#timeline-${dragFrameIndex}`).closest('.timeline-frame-container');
      if (container) {
        const baseWidth = 50; // Base width for 1x duration
        const newWidth = baseWidth * newDuration;
        container.style.width = `${newWidth}px`;
      }
    }

    function stopRibDrag(event) {
      if (!isDraggingRib) return;
      
      isDraggingRib = false;
      
      // Remove visual feedback
      const rib = document.getElementById(`rib-${dragSide}-${dragFrameIndex}`);
      rib.classList.remove('dragging');
      
      const container = rib.closest('.timeline-frame-container');
      container.classList.remove('dragging');
      
      // Remove global event listeners
      document.removeEventListener('mousemove', handleRibDrag);
      document.removeEventListener('mouseup', stopRibDrag);
      
      dragFrameIndex = -1;
      dragSide = '';
    }

    function updateFrameDurationIndicator(frameIndex) {
      const indicator = document.getElementById(`duration-${frameIndex}`);
      if (indicator) {
        const duration = frameDurations[frameIndex];
        // Display with one decimal place for precision
        const displayText = `${duration.toFixed(1)}x`;
        indicator.textContent = displayText;
      }
      
      // Update the timeline frame container width based on duration
      const container = document.querySelector(`#timeline-${frameIndex}`).closest('.timeline-frame-container');
      if (container) {
        const baseWidth = 50; // Base width for 1x duration
        const newWidth = baseWidth * frameDurations[frameIndex];
        container.style.width = `${newWidth}px`;
      }
      
      // Update timeline ruler and total duration
      updateAllTimeScaleIndicators();
    }



    function updateAllTimeScaleIndicators() {
      updateTimelineRuler();
      updateTotalDuration();
    }

    function updateTimelineRuler() {
      const rulerElement = document.getElementById('timeline-ruler');
      if (!rulerElement) return;
      
      // Clear existing ruler
      rulerElement.innerHTML = '';
      
      // Get the actual timeline frame containers to match their exact positions
      const timelineContainers = document.querySelectorAll('.timeline-frame-container');
      if (timelineContainers.length === 0) return;
      
      // Get the timeline container's position and dimensions
      const timelineContainer = timelineContainers[0].parentElement;
      const timelineRect = timelineContainer.getBoundingClientRect();
      const rulerRect = rulerElement.getBoundingClientRect();
      
      // Calculate offset to align ruler with timeline
      const offsetX = timelineRect.left - rulerRect.left;
      
      // Set ruler width to match the timeline container width
      rulerElement.style.width = `${timelineRect.width}px`;
      
      // Calculate total duration for time calculations
      const totalDuration = frameDurations.reduce((sum, duration) => sum + duration, 0);
      const totalTimeInSeconds = totalDuration / fps;
      const pixelsPerSecond = timelineRect.width / Math.max(totalTimeInSeconds, 0.1);
      
      // Add frame markers using exact positions from timeline frames
      for (let i = 0; i < timelineContainers.length; i++) {
        const container = timelineContainers[i];
        const containerRect = container.getBoundingClientRect();
        
        // Calculate position relative to ruler
        const frameStartX = containerRect.left - rulerRect.left;
        const frameWidth = containerRect.width;
        const frameEndX = frameStartX + frameWidth;
        
        // Frame marker
        const frameMarker = document.createElement('div');
        frameMarker.setAttribute('data-frame-index', i);
        frameMarker.style.position = 'absolute';
        frameMarker.style.left = `${frameStartX}px`;
        frameMarker.style.top = '10px';
        frameMarker.style.width = `${frameWidth}px`;
        frameMarker.style.height = '20px';
        frameMarker.style.backgroundColor = i === currentFrame ? '#6366f1' : '#4a4a4a';
        frameMarker.style.border = '1px solid #2a2a2a';
        frameMarker.style.borderRadius = '2px';
        frameMarker.style.zIndex = '5';
        
        // Calculate time for tooltip
        const frameStartTime = frameStartX / pixelsPerSecond;
        const frameEndTime = frameEndX / pixelsPerSecond;
        frameMarker.title = `Frame ${i + 1}: ${frameStartTime.toFixed(1)}s - ${frameEndTime.toFixed(1)}s`;
        
        rulerElement.appendChild(frameMarker);
      }
      
      // Store ruler data for scrubbing
      window.timelineRulerData = {
        totalTimeInSeconds,
        pixelsPerSecond,
        rulerWidth: timelineRect.width,
        offsetX
      };
    }

    function updateTotalDuration() {
      const totalDurationElement = document.getElementById('total-duration');
      if (totalDurationElement) {
        const totalDuration = frameDurations.reduce((sum, duration) => sum + duration, 0);
        const totalTimeInSeconds = totalDuration / fps;
        totalDurationElement.textContent = `${totalTimeInSeconds.toFixed(1)}s`;
      }
    }

    // Timeline scrubbing variables
    let isScrubbing = false;
    let scrubberStartX = 0;

    function startTimelineScrub(event) {
      event.preventDefault();
      isScrubbing = true;
      scrubberStartX = event.clientX;
      
      // Add global event listeners
      document.addEventListener('mousemove', handleTimelineScrub);
      document.addEventListener('mouseup', stopTimelineScrub);
      
      // Update scrubber position
      updateScrubberPosition(event);
    }

    function handleTimelineScrub(event) {
      if (!isScrubbing) return;
      updateScrubberPosition(event);
    }

    function stopTimelineScrub(event) {
      if (!isScrubbing) return;
      isScrubbing = false;
      
      // Remove global event listeners
      document.removeEventListener('mousemove', handleTimelineScrub);
      document.removeEventListener('mouseup', stopTimelineScrub);
    }

    function updateScrubberPosition(event) {
      const rulerElement = document.getElementById('timeline-ruler');
      const scrubberElement = document.getElementById('timeline-scrubber');
      const timeDisplayElement = document.getElementById('timeline-time-display');
      
      if (!rulerElement || !scrubberElement || !window.timelineRulerData) return;
      
      const rect = rulerElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const clampedX = Math.max(0, Math.min(x, window.timelineRulerData.rulerWidth));
      
      // Update scrubber position
      scrubberElement.style.left = `${clampedX}px`;
      
      // Calculate time at this position
      const timeInSeconds = clampedX / window.timelineRulerData.pixelsPerSecond;
      
      // Update time display
      if (timeDisplayElement) {
        timeDisplayElement.textContent = `${timeInSeconds.toFixed(1)}s`;
        timeDisplayElement.style.display = 'block';
      }
      
      // Find which frame this position corresponds to using actual timeline frame positions
      const timelineContainers = document.querySelectorAll('.timeline-frame-container');
      let currentFrameAtTime = -1; // -1 means no frame (between frames)
      
      for (let i = 0; i < timelineContainers.length; i++) {
        const container = timelineContainers[i];
        const containerRect = container.getBoundingClientRect();
        const rulerRect = rulerElement.getBoundingClientRect();
        
        const frameStartX = containerRect.left - rulerRect.left;
        const frameEndX = frameStartX + containerRect.width;
        
        // Only highlight if scrubber is clearly within a frame (not at boundaries)
        if (clampedX > frameStartX && clampedX < frameEndX) {
          currentFrameAtTime = i;
          break;
        }
      }
      
      // Highlight the frame at this time (or clear if between frames)
      updateFrameHighlight(currentFrameAtTime);
    }

    function updateTimelineHover(event) {
      if (isScrubbing) return;
      updateScrubberPosition(event);
    }

    function hideTimelineHover() {
      const timeDisplayElement = document.getElementById('timeline-time-display');
      if (timeDisplayElement) {
        timeDisplayElement.style.display = 'none';
      }
    }

    function updateFrameHighlight(frameIndex) {
      // Update frame markers to show which frame is at the current time
      const rulerElement = document.getElementById('timeline-ruler');
      if (!rulerElement) return;
      
      const frameMarkers = rulerElement.querySelectorAll('[data-frame-index]');
      frameMarkers.forEach((marker, index) => {
        if (frameIndex >= 0 && index === frameIndex) {
          marker.style.backgroundColor = '#6366f1';
          marker.style.borderColor = '#6366f1';
        } else {
          marker.style.backgroundColor = '#4a4a4a';
          marker.style.borderColor = '#2a2a2a';
        }
      });
      
      // Also update the actual timeline frames to show which one is active
      const timelineFrames = document.querySelectorAll('.timeline-frame');
      timelineFrames.forEach((frame, index) => {
        if (frameIndex >= 0 && index === frameIndex) {
          frame.classList.add('active');
        } else {
          frame.classList.remove('active');
        }
      });
    }

    updateLayersList();
    updateFrameLabel();
    composeLayers();
    saveState();
    
    // Initialize frame duration indicators and timeline ruler
    for (let i = 0; i < 6; i++) {
      updateFrameDurationIndicator(i);
    }
    
    // Sync ruler with timeline scroll position
    function syncRulerWithTimeline() {
      const rulerElement = document.getElementById('timeline-ruler');
      const timelineContainer = document.querySelector('.flex.gap-2.pb-6');
      
      if (rulerElement && timelineContainer) {
        // Update ruler position when timeline scrolls
        timelineContainer.addEventListener('scroll', () => {
          rulerElement.style.transform = `translateX(-${timelineContainer.scrollLeft}px)`;
        });
      }
    }
    
    // Initialize ruler sync
    syncRulerWithTimeline();
    
    // Safari scrollbar styling enforcement
    function enforceScrollbarStyling() {
      // Force scrollbar styles to be applied in Safari
      const style = document.createElement('style');
      style.id = 'safari-scrollbar-enforcement';
      style.textContent = `
        /* Safari scrollbar enforcement */
         ::-webkit-scrollbar {
           width: 8px !important;
           height: 8px !important;
           background: #28282e !important;
         }
         ::-webkit-scrollbar-track {
           background: #28282e !important;
         }
         ::-webkit-scrollbar-thumb {
           background: #5a5f65 !important;
           border-radius: 4px !important;
           border: none !important;
         }
        ::-webkit-scrollbar-corner {
          background: transparent !important;
        }
      `;
      
      // Remove existing enforcement if it exists
      const existing = document.getElementById('safari-scrollbar-enforcement');
      if (existing) {
        existing.remove();
      }
      
      // Add the enforcement
      document.head.appendChild(style);
      
      // Force a reflow to ensure styles are applied
      document.body.style.display = 'none';
      document.body.offsetHeight; // Trigger reflow
      document.body.style.display = '';
    }
    
    // Apply scrollbar styling immediately and on load
    enforceScrollbarStyling();
    window.addEventListener('load', enforceScrollbarStyling);
    setTimeout(enforceScrollbarStyling, 100);
    setTimeout(enforceScrollbarStyling, 500);
    
    
    
    /* Set initial viewport to phone on page load */
    setViewport('phone');
    
    function startAutoAnimation() {
      if (!animationInterval) {
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        animationFrame = 0;
        currentFrameTime = 0;
        currentFrameDuration = frameDurations[0];
        animationInterval = setInterval(updateAnimation, 1000 / fps);
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          Pause
        `;
      }
    }

    startAutoAnimation();
  </script>
</body>
</html>



